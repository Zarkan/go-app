package bridge

import (
	"sync"

	"github.com/google/uuid"
	"github.com/pkg/errors"
)

// PlatformBridge is the interface that describes a bridge to communicate from
// Go to an underlying platform.
type PlatformBridge interface {
	// Request issues a request to the specified URL with the payload.
	Request(url string, p Payload) (res Payload, err error)

	// RequestWithAsyncResponse issues a request to the specified URL with the
	// payload.
	// It should be used when the response require to wait platform asynchronous
	// operations.
	RequestWithAsyncResponse(url string, p Payload) (res Payload, err error)

	// Return returns the response with the identifier generated by a call to
	// RequestWithAsyncResponse.
	// It should be called to return a response requested with
	// RequestWithAsyncResponse.
	Return(returnID string, p Payload, err error)
}

// PlatformHandler describes the func that will handle requests to the
// underlying platform.
type PlatformHandler func(url string, p Payload, returnID string) (res Payload, err error)

// NewPlatformBridge creates an underlying platform bridge.
func NewPlatformBridge(h PlatformHandler) PlatformBridge {
	return newPlatformBridge(h)
}

type platformBridge struct {
	handler PlatformHandler
	returns *returnRegistry
}

func newPlatformBridge(h PlatformHandler) *platformBridge {
	return &platformBridge{
		handler: h,
		returns: newReturnRegistry(),
	}
}

func (b *platformBridge) Request(rawurl string, p Payload) (res Payload, err error) {
	res, err = b.handler(rawurl, p, "")
	return
}

func (b *platformBridge) RequestWithAsyncResponse(rawurl string, p Payload) (res Payload, err error) {
	returnID := uuid.New()

	retchan := make(chan returnPayload, 1)
	defer close(retchan)

	b.returns.Set(returnID, retchan)
	defer b.returns.Delete(returnID)

	if _, err = b.handler(rawurl, p, returnID.String()); err != nil {
		return
	}

	ret := <-retchan
	res = ret.response
	err = ret.err
	return
}

func (b *platformBridge) Return(returnID string, res Payload, err error) {
	retID, err := uuid.Parse(returnID)
	if err != nil {
		panic(errors.Wrapf(err, "returning result %s failed", res.String()))
	}

	retchan, ok := b.returns.Get(retID)
	if !ok {
		panic(errors.Errorf("returning result %s failed: no return set for %v",
			res.String(),
			retID))
	}
	retchan <- returnPayload{
		response: res,
		err:      err,
	}
}

type returnPayload struct {
	response Payload
	err      error
}

type returnRegistry struct {
	mutex   sync.Mutex
	returns map[uuid.UUID]chan returnPayload
}

func newReturnRegistry() *returnRegistry {
	return &returnRegistry{
		returns: make(map[uuid.UUID]chan returnPayload),
	}
}

func (r *returnRegistry) Set(id uuid.UUID, retchan chan returnPayload) {
	r.mutex.Lock()
	r.returns[id] = retchan
	r.mutex.Unlock()
}

func (r *returnRegistry) Get(id uuid.UUID) (retchan chan returnPayload, ok bool) {
	r.mutex.Lock()
	retchan, ok = r.returns[id]
	r.mutex.Unlock()
	return
}

func (r *returnRegistry) Delete(id uuid.UUID) {
	r.mutex.Lock()
	delete(r.returns, id)
	r.mutex.Unlock()
}
